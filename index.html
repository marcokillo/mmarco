<!DOCTYPE html>
<html lang="fa">
<head>
  <meta charset="UTF-8">
  <title>Ù¾Ø§Ø²Ù„ ØªØµÙˆÛŒØ±ÛŒ Drag & Drop</title>
  <style>
    body {
      margin: 0;
      background: #111;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    .puzzle-container {
      width: 600px;
      height: 480px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: 2px;
      border: 3px solid #fff;
    }

    .tile {
      background-image: url('https://images.unsplash.com/photo-1506744038136-46273834b3fb?auto=format&fit=crop&w=1000&q=80');
      background-size: 1000px 800px;
      cursor: grab;
      user-select: none;
    }

    .tile.dragging {
      opacity: 0.5;
    }

    .tile.over {
      outline: 2px dashed yellow;
    }
  </style>
</head>
<body>
  <div class="puzzle-container" id="puzzle"></div>

  <script>
    const puzzle = document.getElementById('puzzle');
    const size = 3;
    const tiles = [];

    // Ø³Ø§Ø®Øª Ù‚Ø·Ø¹Ù‡â€ŒÙ‡Ø§ Ø¨Ø§ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø§ÙˆÙ„ÛŒÙ‡ Ø¯Ø±Ø³Øª
    for (let row = 0; row < size; row++) {
      for (let col = 0; col < size; col++) {
        const tile = document.createElement('div');
        tile.classList.add('tile');
        tile.setAttribute('draggable', 'true');
        tile.dataset.correct = row * size + col;
        tile.style.backgroundPosition = -${col * 333}px -${row * 266}px;
        tiles.push(tile);
      }
    }

    // Ø¯Ø±Ù‡Ù…â€ŒØ±ÛŒØ®ØªÙ† Ù‚Ø·Ø¹Ù‡â€ŒÙ‡Ø§
    tiles.sort(() => Math.random() - 0.5);
    tiles.forEach(t => puzzle.appendChild(t));

    // Ù…Ù†Ø·Ù‚ Drag & Drop
    let draggedTile = null;

    puzzle.addEventListener('dragstart', e => {
      if (!e.target.classList.contains('tile')) return;
      draggedTile = e.target;
      draggedTile.classList.add('dragging');
    });

    puzzle.addEventListener('dragend', e => {
      if (draggedTile) draggedTile.classList.remove('dragging');
    });

    puzzle.addEventListener('dragover', e => {
      e.preventDefault();
      const target = e.target;
      if (target.classList.contains('tile') && target !== draggedTile) {
        target.classList.add('over');
      }
    });

    puzzle.addEventListener('dragleave', e => {
      if (e.target.classList.contains('tile')) {
        e.target.classList.remove('over');
      }
    });

    puzzle.addEventListener('drop', e => {
      e.preventDefault();
      const target = e.target;
      if (target.classList.contains('tile') && target !== draggedTile) {
        target.classList.remove('over');

        const clone1 = draggedTile.cloneNode(true);
        const clone2 = target.cloneNode(true);

        puzzle.replaceChild(clone1, target);
        puzzle.replaceChild(clone2, draggedTile);

        addDragEvents(); // Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø¨Ø±Ø§ÛŒ Ù‚Ø·Ø¹Ù‡â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ drag Ø±Ùˆ ÙØ¹Ø§Ù„ Ú©Ù†
        checkIfSolved();
      }
    });

    // Ø§ÙØ²ÙˆØ¯Ù† Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ Ø¨Ù‡ Ù‚Ø·Ø¹Ù‡â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯
    function addDragEvents() {
      document.querySelectorAll('.tile').forEach(tile => {
        tile.addEventListener('dragstart', e => {
          draggedTile = e.target;
          draggedTile.classList.add('dragging');
        });
        tile.addEventListener('dragend', e => {
          if (draggedTile) draggedTile.classList.remove('dragging');
        });
      });
    }

    // Ø¨Ø±Ø±Ø³ÛŒ Ø­Ù„â€ŒØ´Ø¯Ù† Ù¾Ø§Ø²Ù„
    function checkIfSolved() {
      const current = Array.from(puzzle.children);
      const isSolved = current.every((tile, index) => +tile.dataset.correct === index);
      if (isSolved) {
        setTimeout(() => alert("ØªØ¨Ø±ÛŒÚ©! Ù¾Ø§Ø²Ù„ Ú©Ø§Ù…Ù„ Ø´Ø¯ ðŸŽ‰"), 100);
      }
    }

    addDragEvents(); // Ø¨Ø§Ø± Ø§ÙˆÙ„ Ø§Ø¬Ø±Ø§
  </script>
</body>
</html>
